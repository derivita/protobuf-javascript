// source: test.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

import * as jspb from 'google-protobuf';
var goog = jspb;
var proto = {};

import * as google_protobuf_descriptor_pb from 'google-protobuf/google/protobuf/descriptor.js';
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Empty(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Empty, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Empty.displayName = 'proto.jspb.test.Empty';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function EnumContainer(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(EnumContainer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  EnumContainer.displayName = 'proto.jspb.test.EnumContainer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Simple1(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, Simple1.repeatedFields_, null);
};
goog.inherits(Simple1, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Simple1.displayName = 'proto.jspb.test.Simple1';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Simple2(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, Simple2.repeatedFields_, null);
};
goog.inherits(Simple2, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Simple2.displayName = 'proto.jspb.test.Simple2';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function SpecialCases(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(SpecialCases, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  SpecialCases.displayName = 'proto.jspb.test.SpecialCases';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function OptionalFields(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, OptionalFields.repeatedFields_, null);
};
goog.inherits(OptionalFields, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  OptionalFields.displayName = 'proto.jspb.test.OptionalFields';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
OptionalFields.Nested = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(OptionalFields.Nested, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  OptionalFields.Nested.displayName = 'proto.jspb.test.OptionalFields.Nested';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function HasExtensions(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 4, null, null);
};
goog.inherits(HasExtensions, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  HasExtensions.displayName = 'proto.jspb.test.HasExtensions';
}

/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldInfo>}
 */
HasExtensions.extensions = {};


/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
 */
HasExtensions.extensionsBinary = {};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Complex(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, Complex.repeatedFields_, null);
};
goog.inherits(Complex, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Complex.displayName = 'proto.jspb.test.Complex';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
Complex.Nested = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Complex.Nested, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Complex.Nested.displayName = 'proto.jspb.test.Complex.Nested';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function OuterMessage(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(OuterMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  OuterMessage.displayName = 'proto.jspb.test.OuterMessage';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
OuterMessage.Complex = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(OuterMessage.Complex, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  OuterMessage.Complex.displayName = 'proto.jspb.test.OuterMessage.Complex';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function MineField(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(MineField, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  MineField.displayName = 'proto.jspb.test.MineField';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function IsExtension(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(IsExtension, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  IsExtension.displayName = 'proto.jspb.test.IsExtension';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function IndirectExtension(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(IndirectExtension, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  IndirectExtension.displayName = 'proto.jspb.test.IndirectExtension';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function DefaultValues(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(DefaultValues, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  DefaultValues.displayName = 'proto.jspb.test.DefaultValues';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function FloatingPointFields(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, FloatingPointFields.repeatedFields_, null);
};
goog.inherits(FloatingPointFields, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  FloatingPointFields.displayName = 'proto.jspb.test.FloatingPointFields';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function BooleanFields(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, BooleanFields.repeatedFields_, null);
};
goog.inherits(BooleanFields, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  BooleanFields.displayName = 'proto.jspb.test.BooleanFields';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestClone(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 8, TestClone.repeatedFields_, null);
};
goog.inherits(TestClone, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestClone.displayName = 'proto.jspb.test.TestClone';
}

/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldInfo>}
 */
TestClone.extensions = {};


/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
 */
TestClone.extensionsBinary = {};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestCloneExtension(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestCloneExtension, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestCloneExtension.displayName = 'proto.jspb.test.TestCloneExtension';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function CloneExtension(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(CloneExtension, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  CloneExtension.displayName = 'proto.jspb.test.CloneExtension';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestGroup(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, TestGroup.repeatedFields_, null);
};
goog.inherits(TestGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestGroup.displayName = 'proto.jspb.test.TestGroup';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
TestGroup.RepeatedGroup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, TestGroup.RepeatedGroup.repeatedFields_, null);
};
goog.inherits(TestGroup.RepeatedGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestGroup.RepeatedGroup.displayName = 'proto.jspb.test.TestGroup.RepeatedGroup';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
TestGroup.RequiredGroup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestGroup.RequiredGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestGroup.RequiredGroup.displayName = 'proto.jspb.test.TestGroup.RequiredGroup';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
TestGroup.OptionalGroup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestGroup.OptionalGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestGroup.OptionalGroup.displayName = 'proto.jspb.test.TestGroup.OptionalGroup';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestGroup1(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestGroup1, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestGroup1.displayName = 'proto.jspb.test.TestGroup1';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestReservedNames(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 2, null, null);
};
goog.inherits(TestReservedNames, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestReservedNames.displayName = 'proto.jspb.test.TestReservedNames';
}

/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldInfo>}
 */
TestReservedNames.extensions = {};


/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
 */
TestReservedNames.extensionsBinary = {};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestReservedNamesExtension(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestReservedNamesExtension, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestReservedNamesExtension.displayName = 'proto.jspb.test.TestReservedNamesExtension';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestMessageWithOneof(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, TestMessageWithOneof.repeatedFields_, TestMessageWithOneof.oneofGroups_);
};
goog.inherits(TestMessageWithOneof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestMessageWithOneof.displayName = 'proto.jspb.test.TestMessageWithOneof';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestEndsWithBytes(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestEndsWithBytes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestEndsWithBytes.displayName = 'proto.jspb.test.TestEndsWithBytes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestLastFieldBeforePivot(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 2, null, null);
};
goog.inherits(TestLastFieldBeforePivot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestLastFieldBeforePivot.displayName = 'proto.jspb.test.TestLastFieldBeforePivot';
}

/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldInfo>}
 */
TestLastFieldBeforePivot.extensions = {};


/**
 * The extensions registered with this message class. This is a map of
 * extension field number to fieldInfo object.
 *
 * For example:
 *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
 *
 * fieldName contains the JsCompiler renamed field name property so that it
 * works in OPTIMIZED mode.
 *
 * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
 */
TestLastFieldBeforePivot.extensionsBinary = {};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Int64Types(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Int64Types, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Int64Types.displayName = 'proto.jspb.test.Int64Types';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function TestMapFieldsNoBinary(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(TestMapFieldsNoBinary, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  TestMapFieldsNoBinary.displayName = 'proto.jspb.test.TestMapFieldsNoBinary';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function MapValueMessageNoBinary(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(MapValueMessageNoBinary, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  MapValueMessageNoBinary.displayName = 'proto.jspb.test.MapValueMessageNoBinary';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
export function Deeply(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Deeply, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Deeply.displayName = 'proto.jspb.test.Deeply';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
Deeply.Nested = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Deeply.Nested, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Deeply.Nested.displayName = 'proto.jspb.test.Deeply.Nested';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
Deeply.Nested.Message = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(Deeply.Nested.Message, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  Deeply.Nested.Message.displayName = 'proto.jspb.test.Deeply.Nested.Message';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Empty.prototype.toObject = function(opt_includeInstance) {
  return Empty.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Empty} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Empty.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Empty}
 */
Empty.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Empty;
  return Empty.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Empty} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Empty}
 */
Empty.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Empty.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Empty.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Empty} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Empty.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
EnumContainer.prototype.toObject = function(opt_includeInstance) {
  return EnumContainer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.EnumContainer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
EnumContainer.toObject = function(includeInstance, msg) {
  var f, obj = {
outerEnum: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.EnumContainer}
 */
EnumContainer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new EnumContainer;
  return EnumContainer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.EnumContainer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.EnumContainer}
 */
EnumContainer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.jspb.test.OuterEnum} */ (reader.readEnum());
      msg.setOuterEnum(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
EnumContainer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  EnumContainer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.EnumContainer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
EnumContainer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.jspb.test.OuterEnum} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * optional OuterEnum outer_enum = 1;
 * @return {!proto.jspb.test.OuterEnum}
 */
EnumContainer.prototype.getOuterEnum = function() {
  return /** @type {!proto.jspb.test.OuterEnum} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/**
 * @param {!proto.jspb.test.OuterEnum} value
 * @return {!proto.jspb.test.EnumContainer} returns this
 */
EnumContainer.prototype.setOuterEnum = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.EnumContainer} returns this
 */
EnumContainer.prototype.clearOuterEnum = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
EnumContainer.prototype.hasOuterEnum = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
Simple1.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Simple1.prototype.toObject = function(opt_includeInstance) {
  return Simple1.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Simple1} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Simple1.toObject = function(includeInstance, msg) {
  var f, obj = {
aString: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
aRepeatedStringList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f,
aBoolean: (f = jspb.Message.getBooleanField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Simple1}
 */
Simple1.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Simple1;
  return Simple1.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Simple1} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Simple1}
 */
Simple1.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAString(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addARepeatedString(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setABoolean(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Simple1.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Simple1.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Simple1} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Simple1.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getARepeatedStringList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * required string a_string = 1;
 * @return {string}
 */
Simple1.prototype.getAString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.setAString = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.clearAString = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Simple1.prototype.hasAString = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated string a_repeated_string = 2;
 * @return {!Array<string>}
 */
Simple1.prototype.getARepeatedStringList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.setARepeatedStringList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.addARepeatedString = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.clearARepeatedStringList = function() {
  return this.setARepeatedStringList([]);
};


/**
 * optional bool a_boolean = 3;
 * @return {boolean}
 */
Simple1.prototype.getABoolean = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.setABoolean = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Simple1} returns this
 */
Simple1.prototype.clearABoolean = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Simple1.prototype.hasABoolean = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
Simple2.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Simple2.prototype.toObject = function(opt_includeInstance) {
  return Simple2.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Simple2} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Simple2.toObject = function(includeInstance, msg) {
  var f, obj = {
aString: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
aRepeatedStringList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Simple2}
 */
Simple2.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Simple2;
  return Simple2.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Simple2} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Simple2}
 */
Simple2.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAString(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addARepeatedString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Simple2.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Simple2.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Simple2} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Simple2.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getARepeatedStringList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
};


/**
 * required string a_string = 1;
 * @return {string}
 */
Simple2.prototype.getAString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.Simple2} returns this
 */
Simple2.prototype.setAString = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Simple2} returns this
 */
Simple2.prototype.clearAString = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Simple2.prototype.hasAString = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated string a_repeated_string = 2;
 * @return {!Array<string>}
 */
Simple2.prototype.getARepeatedStringList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.jspb.test.Simple2} returns this
 */
Simple2.prototype.setARepeatedStringList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.Simple2} returns this
 */
Simple2.prototype.addARepeatedString = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.Simple2} returns this
 */
Simple2.prototype.clearARepeatedStringList = function() {
  return this.setARepeatedStringList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
SpecialCases.prototype.toObject = function(opt_includeInstance) {
  return SpecialCases.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.SpecialCases} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
SpecialCases.toObject = function(includeInstance, msg) {
  var f, obj = {
normal: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
pb_default: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
pb_function: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
pb_var: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.SpecialCases}
 */
SpecialCases.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new SpecialCases;
  return SpecialCases.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.SpecialCases} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.SpecialCases}
 */
SpecialCases.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNormal(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDefault(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setFunction(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setVar(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
SpecialCases.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  SpecialCases.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.SpecialCases} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
SpecialCases.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * required string normal = 1;
 * @return {string}
 */
SpecialCases.prototype.getNormal = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.setNormal = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.clearNormal = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
SpecialCases.prototype.hasNormal = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required string default = 2;
 * @return {string}
 */
SpecialCases.prototype.getDefault = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.setDefault = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.clearDefault = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
SpecialCases.prototype.hasDefault = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string function = 3;
 * @return {string}
 */
SpecialCases.prototype.getFunction = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.setFunction = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.clearFunction = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
SpecialCases.prototype.hasFunction = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required string var = 4;
 * @return {string}
 */
SpecialCases.prototype.getVar = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.setVar = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.SpecialCases} returns this
 */
SpecialCases.prototype.clearVar = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
SpecialCases.prototype.hasVar = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
OptionalFields.repeatedFields_ = [4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
OptionalFields.prototype.toObject = function(opt_includeInstance) {
  return OptionalFields.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.OptionalFields} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OptionalFields.toObject = function(includeInstance, msg) {
  var f, obj = {
aString: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
aBool: (f = jspb.Message.getBooleanField(msg, 2)) == null ? undefined : f,
aNestedMessage: (f = msg.getANestedMessage()) && OptionalFields.Nested.toObject(includeInstance, f),
aRepeatedMessageList: jspb.Message.toObjectList(msg.getARepeatedMessageList(),
    OptionalFields.Nested.toObject, includeInstance),
aRepeatedStringList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.OptionalFields}
 */
OptionalFields.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new OptionalFields;
  return OptionalFields.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.OptionalFields} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.OptionalFields}
 */
OptionalFields.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAString(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setABool(value);
      break;
    case 3:
      var value = new OptionalFields.Nested;
      reader.readMessage(value,OptionalFields.Nested.deserializeBinaryFromReader);
      msg.setANestedMessage(value);
      break;
    case 4:
      var value = new OptionalFields.Nested;
      reader.readMessage(value,OptionalFields.Nested.deserializeBinaryFromReader);
      msg.addARepeatedMessage(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.addARepeatedString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
OptionalFields.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  OptionalFields.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.OptionalFields} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OptionalFields.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getANestedMessage();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      OptionalFields.Nested.serializeBinaryToWriter
    );
  }
  f = message.getARepeatedMessageList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      OptionalFields.Nested.serializeBinaryToWriter
    );
  }
  f = message.getARepeatedStringList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      5,
      f
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
OptionalFields.Nested.prototype.toObject = function(opt_includeInstance) {
  return OptionalFields.Nested.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.OptionalFields.Nested} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OptionalFields.Nested.toObject = function(includeInstance, msg) {
  var f, obj = {
anInt: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.OptionalFields.Nested}
 */
OptionalFields.Nested.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new OptionalFields.Nested;
  return OptionalFields.Nested.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.OptionalFields.Nested} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.OptionalFields.Nested}
 */
OptionalFields.Nested.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAnInt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
OptionalFields.Nested.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  OptionalFields.Nested.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.OptionalFields.Nested} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OptionalFields.Nested.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 an_int = 1;
 * @return {number}
 */
OptionalFields.Nested.prototype.getAnInt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.OptionalFields.Nested} returns this
 */
OptionalFields.Nested.prototype.setAnInt = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.OptionalFields.Nested} returns this
 */
OptionalFields.Nested.prototype.clearAnInt = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
OptionalFields.Nested.prototype.hasAnInt = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string a_string = 1;
 * @return {string}
 */
OptionalFields.prototype.getAString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.setAString = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.clearAString = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
OptionalFields.prototype.hasAString = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required bool a_bool = 2;
 * @return {boolean}
 */
OptionalFields.prototype.getABool = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.setABool = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.clearABool = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
OptionalFields.prototype.hasABool = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Nested a_nested_message = 3;
 * @return {?proto.jspb.test.OptionalFields.Nested}
 */
OptionalFields.prototype.getANestedMessage = function() {
  return /** @type{?proto.jspb.test.OptionalFields.Nested} */ (
    jspb.Message.getWrapperField(this, OptionalFields.Nested, 3));
};


/**
 * @param {?proto.jspb.test.OptionalFields.Nested|undefined} value
 * @return {!proto.jspb.test.OptionalFields} returns this
*/
OptionalFields.prototype.setANestedMessage = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.clearANestedMessage = function() {
  return this.setANestedMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
OptionalFields.prototype.hasANestedMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated Nested a_repeated_message = 4;
 * @return {!Array<!proto.jspb.test.OptionalFields.Nested>}
 */
OptionalFields.prototype.getARepeatedMessageList = function() {
  return /** @type{!Array<!proto.jspb.test.OptionalFields.Nested>} */ (
    jspb.Message.getRepeatedWrapperField(this, OptionalFields.Nested, 4));
};


/**
 * @param {!Array<!proto.jspb.test.OptionalFields.Nested>} value
 * @return {!proto.jspb.test.OptionalFields} returns this
*/
OptionalFields.prototype.setARepeatedMessageList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.jspb.test.OptionalFields.Nested=} opt_value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.OptionalFields.Nested}
 */
OptionalFields.prototype.addARepeatedMessage = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, OptionalFields.Nested, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.clearARepeatedMessageList = function() {
  return this.setARepeatedMessageList([]);
};


/**
 * repeated string a_repeated_string = 5;
 * @return {!Array<string>}
 */
OptionalFields.prototype.getARepeatedStringList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.setARepeatedStringList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.addARepeatedString = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.OptionalFields} returns this
 */
OptionalFields.prototype.clearARepeatedStringList = function() {
  return this.setARepeatedStringList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
HasExtensions.prototype.toObject = function(opt_includeInstance) {
  return HasExtensions.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.HasExtensions} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
HasExtensions.toObject = function(includeInstance, msg) {
  var f, obj = {
str1: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
str2: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
str3: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  jspb.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
      HasExtensions.extensions, HasExtensions.prototype.getExtension,
      includeInstance);
  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.HasExtensions}
 */
HasExtensions.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new HasExtensions;
  return HasExtensions.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.HasExtensions} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.HasExtensions}
 */
HasExtensions.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setStr1(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setStr2(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setStr3(value);
      break;
    default:
      jspb.Message.readBinaryExtension(msg, reader,
        HasExtensions.extensionsBinary,
        HasExtensions.prototype.getExtension,
        HasExtensions.prototype.setExtension);
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
HasExtensions.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  HasExtensions.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.HasExtensions} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
HasExtensions.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  jspb.Message.serializeBinaryExtensions(message, writer,
    HasExtensions.extensionsBinary, HasExtensions.prototype.getExtension);
};


/**
 * optional string str1 = 1;
 * @return {string}
 */
HasExtensions.prototype.getStr1 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.setStr1 = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.clearStr1 = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
HasExtensions.prototype.hasStr1 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string str2 = 2;
 * @return {string}
 */
HasExtensions.prototype.getStr2 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.setStr2 = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.clearStr2 = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
HasExtensions.prototype.hasStr2 = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string str3 = 3;
 * @return {string}
 */
HasExtensions.prototype.getStr3 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.setStr3 = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.HasExtensions} returns this
 */
HasExtensions.prototype.clearStr3 = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
HasExtensions.prototype.hasStr3 = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
Complex.repeatedFields_ = [5,7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Complex.prototype.toObject = function(opt_includeInstance) {
  return Complex.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Complex} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Complex.toObject = function(includeInstance, msg) {
  var f, obj = {
aString: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
anOutOfOrderBool: (f = jspb.Message.getBooleanField(msg, 9)) == null ? undefined : f,
aNestedMessage: (f = msg.getANestedMessage()) && Complex.Nested.toObject(includeInstance, f),
aRepeatedMessageList: jspb.Message.toObjectList(msg.getARepeatedMessageList(),
    Complex.Nested.toObject, includeInstance),
aRepeatedStringList: (f = jspb.Message.getRepeatedField(msg, 7)) == null ? undefined : f,
aFloatingPointField: (f = jspb.Message.getOptionalFloatingPointField(msg, 10)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Complex}
 */
Complex.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Complex;
  return Complex.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Complex} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Complex}
 */
Complex.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAString(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAnOutOfOrderBool(value);
      break;
    case 4:
      var value = new Complex.Nested;
      reader.readMessage(value,Complex.Nested.deserializeBinaryFromReader);
      msg.setANestedMessage(value);
      break;
    case 5:
      var value = new Complex.Nested;
      reader.readMessage(value,Complex.Nested.deserializeBinaryFromReader);
      msg.addARepeatedMessage(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.addARepeatedString(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setAFloatingPointField(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Complex.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Complex.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Complex} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Complex.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getANestedMessage();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      Complex.Nested.serializeBinaryToWriter
    );
  }
  f = message.getARepeatedMessageList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      Complex.Nested.serializeBinaryToWriter
    );
  }
  f = message.getARepeatedStringList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeDouble(
      10,
      f
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Complex.Nested.prototype.toObject = function(opt_includeInstance) {
  return Complex.Nested.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Complex.Nested} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Complex.Nested.toObject = function(includeInstance, msg) {
  var f, obj = {
anInt: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Complex.Nested}
 */
Complex.Nested.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Complex.Nested;
  return Complex.Nested.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Complex.Nested} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Complex.Nested}
 */
Complex.Nested.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAnInt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Complex.Nested.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Complex.Nested.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Complex.Nested} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Complex.Nested.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * required int32 an_int = 2;
 * @return {number}
 */
Complex.Nested.prototype.getAnInt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.Complex.Nested} returns this
 */
Complex.Nested.prototype.setAnInt = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Complex.Nested} returns this
 */
Complex.Nested.prototype.clearAnInt = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Complex.Nested.prototype.hasAnInt = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string a_string = 1;
 * @return {string}
 */
Complex.prototype.getAString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.setAString = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearAString = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Complex.prototype.hasAString = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool an_out_of_order_bool = 9;
 * @return {boolean}
 */
Complex.prototype.getAnOutOfOrderBool = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 9, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.setAnOutOfOrderBool = function(value) {
  return jspb.Message.setField(this, 9, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearAnOutOfOrderBool = function() {
  return jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Complex.prototype.hasAnOutOfOrderBool = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional Nested a_nested_message = 4;
 * @return {?proto.jspb.test.Complex.Nested}
 */
Complex.prototype.getANestedMessage = function() {
  return /** @type{?proto.jspb.test.Complex.Nested} */ (
    jspb.Message.getWrapperField(this, Complex.Nested, 4));
};


/**
 * @param {?proto.jspb.test.Complex.Nested|undefined} value
 * @return {!proto.jspb.test.Complex} returns this
*/
Complex.prototype.setANestedMessage = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearANestedMessage = function() {
  return this.setANestedMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Complex.prototype.hasANestedMessage = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * repeated Nested a_repeated_message = 5;
 * @return {!Array<!proto.jspb.test.Complex.Nested>}
 */
Complex.prototype.getARepeatedMessageList = function() {
  return /** @type{!Array<!proto.jspb.test.Complex.Nested>} */ (
    jspb.Message.getRepeatedWrapperField(this, Complex.Nested, 5));
};


/**
 * @param {!Array<!proto.jspb.test.Complex.Nested>} value
 * @return {!proto.jspb.test.Complex} returns this
*/
Complex.prototype.setARepeatedMessageList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.jspb.test.Complex.Nested=} opt_value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.Complex.Nested}
 */
Complex.prototype.addARepeatedMessage = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, Complex.Nested, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearARepeatedMessageList = function() {
  return this.setARepeatedMessageList([]);
};


/**
 * repeated string a_repeated_string = 7;
 * @return {!Array<string>}
 */
Complex.prototype.getARepeatedStringList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 7));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.setARepeatedStringList = function(value) {
  return jspb.Message.setField(this, 7, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.addARepeatedString = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 7, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearARepeatedStringList = function() {
  return this.setARepeatedStringList([]);
};


/**
 * optional double a_floating_point_field = 10;
 * @return {number}
 */
Complex.prototype.getAFloatingPointField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 10, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.setAFloatingPointField = function(value) {
  return jspb.Message.setField(this, 10, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Complex} returns this
 */
Complex.prototype.clearAFloatingPointField = function() {
  return jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Complex.prototype.hasAFloatingPointField = function() {
  return jspb.Message.getField(this, 10) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
OuterMessage.prototype.toObject = function(opt_includeInstance) {
  return OuterMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.OuterMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OuterMessage.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.OuterMessage}
 */
OuterMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new OuterMessage;
  return OuterMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.OuterMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.OuterMessage}
 */
OuterMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
OuterMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  OuterMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.OuterMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OuterMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
OuterMessage.Complex.prototype.toObject = function(opt_includeInstance) {
  return OuterMessage.Complex.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.OuterMessage.Complex} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OuterMessage.Complex.toObject = function(includeInstance, msg) {
  var f, obj = {
innerComplexField: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.OuterMessage.Complex}
 */
OuterMessage.Complex.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new OuterMessage.Complex;
  return OuterMessage.Complex.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.OuterMessage.Complex} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.OuterMessage.Complex}
 */
OuterMessage.Complex.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setInnerComplexField(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
OuterMessage.Complex.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  OuterMessage.Complex.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.OuterMessage.Complex} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
OuterMessage.Complex.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 inner_complex_field = 1;
 * @return {number}
 */
OuterMessage.Complex.prototype.getInnerComplexField = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.OuterMessage.Complex} returns this
 */
OuterMessage.Complex.prototype.setInnerComplexField = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.OuterMessage.Complex} returns this
 */
OuterMessage.Complex.prototype.clearInnerComplexField = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
OuterMessage.Complex.prototype.hasInnerComplexField = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
MineField.prototype.toObject = function(opt_includeInstance) {
  return MineField.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.MineField} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
MineField.toObject = function(includeInstance, msg) {
  var f, obj = {
cookie: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.MineField}
 */
MineField.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new MineField;
  return MineField.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.MineField} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.MineField}
 */
MineField.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setCookie(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
MineField.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  MineField.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.MineField} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
MineField.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string cookie = 1;
 * @return {string}
 */
MineField.prototype.getCookie = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.MineField} returns this
 */
MineField.prototype.setCookie = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.MineField} returns this
 */
MineField.prototype.clearCookie = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
MineField.prototype.hasCookie = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
IsExtension.prototype.toObject = function(opt_includeInstance) {
  return IsExtension.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.IsExtension} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
IsExtension.toObject = function(includeInstance, msg) {
  var f, obj = {
ext1: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.IsExtension}
 */
IsExtension.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new IsExtension;
  return IsExtension.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.IsExtension} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.IsExtension}
 */
IsExtension.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setExt1(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
IsExtension.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  IsExtension.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.IsExtension} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
IsExtension.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `extField`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.IsExtension>}
 */
IsExtension.extField = new jspb.ExtensionFieldInfo(
    100,
    {extField: 0},
    IsExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         IsExtension.toObject),
    0);

HasExtensions.extensionsBinary[100] = new jspb.ExtensionFieldBinaryInfo(
    IsExtension.extField,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    IsExtension.serializeBinaryToWriter,
    IsExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[100] = IsExtension.extField;

/**
 * optional string ext1 = 1;
 * @return {string}
 */
IsExtension.prototype.getExt1 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.IsExtension} returns this
 */
IsExtension.prototype.setExt1 = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.IsExtension} returns this
 */
IsExtension.prototype.clearExt1 = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
IsExtension.prototype.hasExt1 = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `extField`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.IsExtension>}
 */
IsExtension.extField = new jspb.ExtensionFieldInfo(
    100,
    {extField: 0},
    IsExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         IsExtension.toObject),
    0);

HasExtensions.extensionsBinary[100] = new jspb.ExtensionFieldBinaryInfo(
    IsExtension.extField,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    IsExtension.serializeBinaryToWriter,
    IsExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[100] = IsExtension.extField;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `simpleOption`.
 * @type {!jspb.ExtensionFieldInfo<string>}
 */
IsExtension.simpleOption = new jspb.ExtensionFieldInfo(
    42113038,
    {simpleOption: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

google_protobuf_descriptor_pb.EnumOptions.extensionsBinary[42113038] = new jspb.ExtensionFieldBinaryInfo(
    IsExtension.simpleOption,
    jspb.BinaryReader.prototype.readString,
    jspb.BinaryWriter.prototype.writeString,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
google_protobuf_descriptor_pb.EnumOptions.extensions[42113038] = IsExtension.simpleOption;




if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
IndirectExtension.prototype.toObject = function(opt_includeInstance) {
  return IndirectExtension.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.IndirectExtension} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
IndirectExtension.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.IndirectExtension}
 */
IndirectExtension.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new IndirectExtension;
  return IndirectExtension.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.IndirectExtension} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.IndirectExtension}
 */
IndirectExtension.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
IndirectExtension.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  IndirectExtension.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.IndirectExtension} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
IndirectExtension.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `simple`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.Simple1>}
 */
IndirectExtension.simple = new jspb.ExtensionFieldInfo(
    101,
    {simple: 0},
    Simple1,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         Simple1.toObject),
    0);

HasExtensions.extensionsBinary[101] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.simple,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    Simple1.serializeBinaryToWriter,
    Simple1.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[101] = IndirectExtension.simple;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `str`.
 * @type {!jspb.ExtensionFieldInfo<string>}
 */
IndirectExtension.str = new jspb.ExtensionFieldInfo(
    102,
    {str: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

HasExtensions.extensionsBinary[102] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.str,
    jspb.BinaryReader.prototype.readString,
    jspb.BinaryWriter.prototype.writeString,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[102] = IndirectExtension.str;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `repeatedStrList`.
 * @type {!jspb.ExtensionFieldInfo<!Array<string>>}
 */
IndirectExtension.repeatedStrList = new jspb.ExtensionFieldInfo(
    103,
    {repeatedStrList: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    1);

HasExtensions.extensionsBinary[103] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.repeatedStrList,
    jspb.BinaryReader.prototype.readString,
    jspb.BinaryWriter.prototype.writeRepeatedString,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[103] = IndirectExtension.repeatedStrList;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `repeatedSimpleList`.
 * @type {!jspb.ExtensionFieldInfo<!Array<!proto.jspb.test.Simple1>>}
 */
IndirectExtension.repeatedSimpleList = new jspb.ExtensionFieldInfo(
    104,
    {repeatedSimpleList: 0},
    Simple1,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         Simple1.toObject),
    1);

HasExtensions.extensionsBinary[104] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.repeatedSimpleList,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeRepeatedMessage,
    Simple1.serializeBinaryToWriter,
    Simple1.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[104] = IndirectExtension.repeatedSimpleList;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `simple`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.Simple1>}
 */
IndirectExtension.simple = new jspb.ExtensionFieldInfo(
    101,
    {simple: 0},
    Simple1,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         Simple1.toObject),
    0);

HasExtensions.extensionsBinary[101] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.simple,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    Simple1.serializeBinaryToWriter,
    Simple1.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[101] = IndirectExtension.simple;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `str`.
 * @type {!jspb.ExtensionFieldInfo<string>}
 */
IndirectExtension.str = new jspb.ExtensionFieldInfo(
    102,
    {str: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

HasExtensions.extensionsBinary[102] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.str,
    jspb.BinaryReader.prototype.readString,
    jspb.BinaryWriter.prototype.writeString,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[102] = IndirectExtension.str;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `repeatedStrList`.
 * @type {!jspb.ExtensionFieldInfo<!Array<string>>}
 */
IndirectExtension.repeatedStrList = new jspb.ExtensionFieldInfo(
    103,
    {repeatedStrList: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    1);

HasExtensions.extensionsBinary[103] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.repeatedStrList,
    jspb.BinaryReader.prototype.readString,
    jspb.BinaryWriter.prototype.writeRepeatedString,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[103] = IndirectExtension.repeatedStrList;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `repeatedSimpleList`.
 * @type {!jspb.ExtensionFieldInfo<!Array<!proto.jspb.test.Simple1>>}
 */
IndirectExtension.repeatedSimpleList = new jspb.ExtensionFieldInfo(
    104,
    {repeatedSimpleList: 0},
    Simple1,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         Simple1.toObject),
    1);

HasExtensions.extensionsBinary[104] = new jspb.ExtensionFieldBinaryInfo(
    IndirectExtension.repeatedSimpleList,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeRepeatedMessage,
    Simple1.serializeBinaryToWriter,
    Simple1.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[104] = IndirectExtension.repeatedSimpleList;




if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
DefaultValues.prototype.toObject = function(opt_includeInstance) {
  return DefaultValues.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.DefaultValues} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
DefaultValues.toObject = function(includeInstance, msg) {
  var f, obj = {
stringField: jspb.Message.getFieldWithDefault(msg, 1, "default\x3c\x3e\x27\x22abc"),
boolField: jspb.Message.getBooleanFieldWithDefault(msg, 2, true),
intField: jspb.Message.getFieldWithDefault(msg, 3, 11),
enumField: jspb.Message.getFieldWithDefault(msg, 4, 13),
emptyField: jspb.Message.getFieldWithDefault(msg, 6, ""),
bytesField: msg.getBytesField_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.DefaultValues}
 */
DefaultValues.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new DefaultValues;
  return DefaultValues.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.DefaultValues} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.DefaultValues}
 */
DefaultValues.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setStringField(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBoolField(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setIntField(value);
      break;
    case 4:
      var value = /** @type {!proto.jspb.test.DefaultValues.Enum} */ (reader.readEnum());
      msg.setEnumField(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setEmptyField(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBytesField(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
DefaultValues.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  DefaultValues.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.DefaultValues} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
DefaultValues.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = /** @type {!proto.jspb.test.DefaultValues.Enum} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBytes(
      8,
      f
    );
  }
};


/**
 * @enum {number}
 */
DefaultValues.Enum = {
  E1: 13,
  E2: 77
};

/**
 * optional string string_field = 1;
 * @return {string}
 */
DefaultValues.prototype.getStringField = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "default\x3c\x3e\x27\x22abc"));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setStringField = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearStringField = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasStringField = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool bool_field = 2;
 * @return {boolean}
 */
DefaultValues.prototype.getBoolField = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, true));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setBoolField = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearBoolField = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasBoolField = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int64 int_field = 3;
 * @return {number}
 */
DefaultValues.prototype.getIntField = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 11));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setIntField = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearIntField = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasIntField = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Enum enum_field = 4;
 * @return {!proto.jspb.test.DefaultValues.Enum}
 */
DefaultValues.prototype.getEnumField = function() {
  return /** @type {!proto.jspb.test.DefaultValues.Enum} */ (jspb.Message.getFieldWithDefault(this, 4, 13));
};


/**
 * @param {!proto.jspb.test.DefaultValues.Enum} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setEnumField = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearEnumField = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasEnumField = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string empty_field = 6;
 * @return {string}
 */
DefaultValues.prototype.getEmptyField = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setEmptyField = function(value) {
  return jspb.Message.setField(this, 6, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearEmptyField = function() {
  return jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasEmptyField = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bytes bytes_field = 8;
 * @return {!(string|Uint8Array)}
 */
DefaultValues.prototype.getBytesField = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 8, "bW9v"));
};


/**
 * optional bytes bytes_field = 8;
 * This is a type-conversion wrapper around `getBytesField()`
 * @return {string}
 */
DefaultValues.prototype.getBytesField_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBytesField()));
};


/**
 * optional bytes bytes_field = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBytesField()`
 * @return {!Uint8Array}
 */
DefaultValues.prototype.getBytesField_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBytesField()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.setBytesField = function(value) {
  return jspb.Message.setField(this, 8, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.DefaultValues} returns this
 */
DefaultValues.prototype.clearBytesField = function() {
  return jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
DefaultValues.prototype.hasBytesField = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
FloatingPointFields.repeatedFields_ = [3,7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
FloatingPointFields.prototype.toObject = function(opt_includeInstance) {
  return FloatingPointFields.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.FloatingPointFields} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
FloatingPointFields.toObject = function(includeInstance, msg) {
  var f, obj = {
optionalFloatField: (f = jspb.Message.getOptionalFloatingPointField(msg, 1)) == null ? undefined : f,
requiredFloatField: (f = jspb.Message.getOptionalFloatingPointField(msg, 2)) == null ? undefined : f,
repeatedFloatFieldList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 3)) == null ? undefined : f,
defaultFloatField: jspb.Message.getFloatingPointFieldWithDefault(msg, 4, 2.0),
optionalDoubleField: (f = jspb.Message.getOptionalFloatingPointField(msg, 5)) == null ? undefined : f,
requiredDoubleField: (f = jspb.Message.getOptionalFloatingPointField(msg, 6)) == null ? undefined : f,
repeatedDoubleFieldList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 7)) == null ? undefined : f,
defaultDoubleField: jspb.Message.getFloatingPointFieldWithDefault(msg, 8, 2.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.FloatingPointFields}
 */
FloatingPointFields.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new FloatingPointFields;
  return FloatingPointFields.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.FloatingPointFields} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.FloatingPointFields}
 */
FloatingPointFields.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setOptionalFloatField(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRequiredFloatField(value);
      break;
    case 3:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readFloat() : [reader.readFloat()]);
      for (var i = 0; i < values.length; i++) {
        msg.addRepeatedFloatField(values[i]);
      }
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDefaultFloatField(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setOptionalDoubleField(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setRequiredDoubleField(value);
      break;
    case 7:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readDouble() : [reader.readDouble()]);
      for (var i = 0; i < values.length; i++) {
        msg.addRepeatedDoubleField(values[i]);
      }
      break;
    case 8:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setDefaultDoubleField(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
FloatingPointFields.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  FloatingPointFields.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.FloatingPointFields} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
FloatingPointFields.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getRepeatedFloatFieldList();
  if (f.length > 0) {
    writer.writeRepeatedFloat(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeDouble(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeDouble(
      6,
      f
    );
  }
  f = message.getRepeatedDoubleFieldList();
  if (f.length > 0) {
    writer.writeRepeatedDouble(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeDouble(
      8,
      f
    );
  }
};


/**
 * optional float optional_float_field = 1;
 * @return {number}
 */
FloatingPointFields.prototype.getOptionalFloatField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setOptionalFloatField = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearOptionalFloatField = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasOptionalFloatField = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required float required_float_field = 2;
 * @return {number}
 */
FloatingPointFields.prototype.getRequiredFloatField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setRequiredFloatField = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearRequiredFloatField = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasRequiredFloatField = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated float repeated_float_field = 3;
 * @return {!Array<number>}
 */
FloatingPointFields.prototype.getRepeatedFloatFieldList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 3));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setRepeatedFloatFieldList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.addRepeatedFloatField = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearRepeatedFloatFieldList = function() {
  return this.setRepeatedFloatFieldList([]);
};


/**
 * optional float default_float_field = 4;
 * @return {number}
 */
FloatingPointFields.prototype.getDefaultFloatField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 4, 2.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setDefaultFloatField = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearDefaultFloatField = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasDefaultFloatField = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional double optional_double_field = 5;
 * @return {number}
 */
FloatingPointFields.prototype.getOptionalDoubleField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 5, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setOptionalDoubleField = function(value) {
  return jspb.Message.setField(this, 5, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearOptionalDoubleField = function() {
  return jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasOptionalDoubleField = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * required double required_double_field = 6;
 * @return {number}
 */
FloatingPointFields.prototype.getRequiredDoubleField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 6, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setRequiredDoubleField = function(value) {
  return jspb.Message.setField(this, 6, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearRequiredDoubleField = function() {
  return jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasRequiredDoubleField = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * repeated double repeated_double_field = 7;
 * @return {!Array<number>}
 */
FloatingPointFields.prototype.getRepeatedDoubleFieldList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 7));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setRepeatedDoubleFieldList = function(value) {
  return jspb.Message.setField(this, 7, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.addRepeatedDoubleField = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 7, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearRepeatedDoubleFieldList = function() {
  return this.setRepeatedDoubleFieldList([]);
};


/**
 * optional double default_double_field = 8;
 * @return {number}
 */
FloatingPointFields.prototype.getDefaultDoubleField = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 8, 2.0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.setDefaultDoubleField = function(value) {
  return jspb.Message.setField(this, 8, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.FloatingPointFields} returns this
 */
FloatingPointFields.prototype.clearDefaultDoubleField = function() {
  return jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
FloatingPointFields.prototype.hasDefaultDoubleField = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
BooleanFields.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
BooleanFields.prototype.toObject = function(opt_includeInstance) {
  return BooleanFields.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.BooleanFields} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
BooleanFields.toObject = function(includeInstance, msg) {
  var f, obj = {
optionalBooleanField: (f = jspb.Message.getBooleanField(msg, 1)) == null ? undefined : f,
requiredBooleanField: (f = jspb.Message.getBooleanField(msg, 2)) == null ? undefined : f,
repeatedBooleanFieldList: (f = jspb.Message.getRepeatedBooleanField(msg, 3)) == null ? undefined : f,
defaultBooleanField: jspb.Message.getBooleanFieldWithDefault(msg, 4, true)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.BooleanFields}
 */
BooleanFields.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new BooleanFields;
  return BooleanFields.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.BooleanFields} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.BooleanFields}
 */
BooleanFields.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOptionalBooleanField(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRequiredBooleanField(value);
      break;
    case 3:
      var values = /** @type {!Array<boolean>} */ (reader.isDelimited() ? reader.readBool() : [reader.readBool()]);
      for (var i = 0; i < values.length; i++) {
        msg.addRepeatedBooleanField(values[i]);
      }
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDefaultBooleanField(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
BooleanFields.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  BooleanFields.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.BooleanFields} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
BooleanFields.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRepeatedBooleanFieldList();
  if (f.length > 0) {
    writer.writeRepeatedBool(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional bool optional_boolean_field = 1;
 * @return {boolean}
 */
BooleanFields.prototype.getOptionalBooleanField = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.setOptionalBooleanField = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.clearOptionalBooleanField = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
BooleanFields.prototype.hasOptionalBooleanField = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required bool required_boolean_field = 2;
 * @return {boolean}
 */
BooleanFields.prototype.getRequiredBooleanField = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.setRequiredBooleanField = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.clearRequiredBooleanField = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
BooleanFields.prototype.hasRequiredBooleanField = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated bool repeated_boolean_field = 3;
 * @return {!Array<boolean>}
 */
BooleanFields.prototype.getRepeatedBooleanFieldList = function() {
  return /** @type {!Array<boolean>} */ (jspb.Message.getRepeatedBooleanField(this, 3));
};


/**
 * @param {!Array<boolean>} value
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.setRepeatedBooleanFieldList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {boolean} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.addRepeatedBooleanField = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.clearRepeatedBooleanFieldList = function() {
  return this.setRepeatedBooleanFieldList([]);
};


/**
 * optional bool default_boolean_field = 4;
 * @return {boolean}
 */
BooleanFields.prototype.getDefaultBooleanField = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, true));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.setDefaultBooleanField = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.BooleanFields} returns this
 */
BooleanFields.prototype.clearDefaultBooleanField = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
BooleanFields.prototype.hasDefaultBooleanField = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
TestClone.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestClone.prototype.toObject = function(opt_includeInstance) {
  return TestClone.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestClone} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestClone.toObject = function(includeInstance, msg) {
  var f, obj = {
str: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
simple1: (f = msg.getSimple1()) && Simple1.toObject(includeInstance, f),
simple2List: jspb.Message.toObjectList(msg.getSimple2List(),
    Simple1.toObject, includeInstance),
bytesField: msg.getBytesField_asB64(),
unused: (f = jspb.Message.getField(msg, 7)) == null ? undefined : f
  };

  jspb.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
      TestClone.extensions, TestClone.prototype.getExtension,
      includeInstance);
  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestClone}
 */
TestClone.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestClone;
  return TestClone.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestClone} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestClone}
 */
TestClone.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setStr(value);
      break;
    case 3:
      var value = new Simple1;
      reader.readMessage(value,Simple1.deserializeBinaryFromReader);
      msg.setSimple1(value);
      break;
    case 5:
      var value = new Simple1;
      reader.readMessage(value,Simple1.deserializeBinaryFromReader);
      msg.addSimple2(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBytesField(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setUnused(value);
      break;
    default:
      jspb.Message.readBinaryExtension(msg, reader,
        TestClone.extensionsBinary,
        TestClone.prototype.getExtension,
        TestClone.prototype.setExtension);
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestClone.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestClone.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestClone} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestClone.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSimple1();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      Simple1.serializeBinaryToWriter
    );
  }
  f = message.getSimple2List();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      Simple1.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeString(
      7,
      f
    );
  }
  jspb.Message.serializeBinaryExtensions(message, writer,
    TestClone.extensionsBinary, TestClone.prototype.getExtension);
};


/**
 * optional string str = 1;
 * @return {string}
 */
TestClone.prototype.getStr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.setStr = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.clearStr = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestClone.prototype.hasStr = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Simple1 simple1 = 3;
 * @return {?proto.jspb.test.Simple1}
 */
TestClone.prototype.getSimple1 = function() {
  return /** @type{?proto.jspb.test.Simple1} */ (
    jspb.Message.getWrapperField(this, Simple1, 3));
};


/**
 * @param {?proto.jspb.test.Simple1|undefined} value
 * @return {!proto.jspb.test.TestClone} returns this
*/
TestClone.prototype.setSimple1 = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.clearSimple1 = function() {
  return this.setSimple1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestClone.prototype.hasSimple1 = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated Simple1 simple2 = 5;
 * @return {!Array<!proto.jspb.test.Simple1>}
 */
TestClone.prototype.getSimple2List = function() {
  return /** @type{!Array<!proto.jspb.test.Simple1>} */ (
    jspb.Message.getRepeatedWrapperField(this, Simple1, 5));
};


/**
 * @param {!Array<!proto.jspb.test.Simple1>} value
 * @return {!proto.jspb.test.TestClone} returns this
*/
TestClone.prototype.setSimple2List = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.jspb.test.Simple1=} opt_value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.Simple1}
 */
TestClone.prototype.addSimple2 = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, Simple1, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.clearSimple2List = function() {
  return this.setSimple2List([]);
};


/**
 * optional bytes bytes_field = 6;
 * @return {!(string|Uint8Array)}
 */
TestClone.prototype.getBytesField = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes bytes_field = 6;
 * This is a type-conversion wrapper around `getBytesField()`
 * @return {string}
 */
TestClone.prototype.getBytesField_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBytesField()));
};


/**
 * optional bytes bytes_field = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBytesField()`
 * @return {!Uint8Array}
 */
TestClone.prototype.getBytesField_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBytesField()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.setBytesField = function(value) {
  return jspb.Message.setField(this, 6, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.clearBytesField = function() {
  return jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestClone.prototype.hasBytesField = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional string unused = 7;
 * @return {string}
 */
TestClone.prototype.getUnused = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.setUnused = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestClone} returns this
 */
TestClone.prototype.clearUnused = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestClone.prototype.hasUnused = function() {
  return jspb.Message.getField(this, 7) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestCloneExtension.prototype.toObject = function(opt_includeInstance) {
  return TestCloneExtension.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestCloneExtension} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestCloneExtension.toObject = function(includeInstance, msg) {
  var f, obj = {
f: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestCloneExtension}
 */
TestCloneExtension.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestCloneExtension;
  return TestCloneExtension.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestCloneExtension} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestCloneExtension}
 */
TestCloneExtension.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setF(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestCloneExtension.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestCloneExtension.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestCloneExtension} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestCloneExtension.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `lowExt`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.TestCloneExtension>}
 */
TestCloneExtension.lowExt = new jspb.ExtensionFieldInfo(
    11,
    {lowExt: 0},
    TestCloneExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         TestCloneExtension.toObject),
    0);

TestClone.extensionsBinary[11] = new jspb.ExtensionFieldBinaryInfo(
    TestCloneExtension.lowExt,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    TestCloneExtension.serializeBinaryToWriter,
    TestCloneExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestClone.extensions[11] = TestCloneExtension.lowExt;

/**
 * optional int32 f = 1;
 * @return {number}
 */
TestCloneExtension.prototype.getF = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestCloneExtension} returns this
 */
TestCloneExtension.prototype.setF = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestCloneExtension} returns this
 */
TestCloneExtension.prototype.clearF = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestCloneExtension.prototype.hasF = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `lowExt`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.TestCloneExtension>}
 */
TestCloneExtension.lowExt = new jspb.ExtensionFieldInfo(
    11,
    {lowExt: 0},
    TestCloneExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         TestCloneExtension.toObject),
    0);

TestClone.extensionsBinary[11] = new jspb.ExtensionFieldBinaryInfo(
    TestCloneExtension.lowExt,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    TestCloneExtension.serializeBinaryToWriter,
    TestCloneExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestClone.extensions[11] = TestCloneExtension.lowExt;




if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
CloneExtension.prototype.toObject = function(opt_includeInstance) {
  return CloneExtension.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.CloneExtension} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
CloneExtension.toObject = function(includeInstance, msg) {
  var f, obj = {
ext: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.CloneExtension}
 */
CloneExtension.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new CloneExtension;
  return CloneExtension.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.CloneExtension} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.CloneExtension}
 */
CloneExtension.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setExt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
CloneExtension.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  CloneExtension.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.CloneExtension} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
CloneExtension.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `extField`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.CloneExtension>}
 */
CloneExtension.extField = new jspb.ExtensionFieldInfo(
    100,
    {extField: 0},
    CloneExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         CloneExtension.toObject),
    0);

TestClone.extensionsBinary[100] = new jspb.ExtensionFieldBinaryInfo(
    CloneExtension.extField,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    CloneExtension.serializeBinaryToWriter,
    CloneExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestClone.extensions[100] = CloneExtension.extField;

/**
 * optional string ext = 2;
 * @return {string}
 */
CloneExtension.prototype.getExt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.CloneExtension} returns this
 */
CloneExtension.prototype.setExt = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.CloneExtension} returns this
 */
CloneExtension.prototype.clearExt = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
CloneExtension.prototype.hasExt = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `extField`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.CloneExtension>}
 */
CloneExtension.extField = new jspb.ExtensionFieldInfo(
    100,
    {extField: 0},
    CloneExtension,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         CloneExtension.toObject),
    0);

TestClone.extensionsBinary[100] = new jspb.ExtensionFieldBinaryInfo(
    CloneExtension.extField,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    CloneExtension.serializeBinaryToWriter,
    CloneExtension.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestClone.extensions[100] = CloneExtension.extField;


/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
TestGroup.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestGroup.prototype.toObject = function(opt_includeInstance) {
  return TestGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
repeatedGroupList: jspb.Message.toObjectList(msg.getRepeatedGroupList(),
    TestGroup.RepeatedGroup.toObject, includeInstance),
requiredGroup: (f = msg.getRequiredGroup()) && TestGroup.RequiredGroup.toObject(includeInstance, f),
optionalGroup: (f = msg.getOptionalGroup()) && TestGroup.OptionalGroup.toObject(includeInstance, f),
id: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f,
requiredSimple: (f = msg.getRequiredSimple()) && Simple2.toObject(includeInstance, f),
optionalSimple: (f = msg.getOptionalSimple()) && Simple2.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestGroup}
 */
TestGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestGroup;
  return TestGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestGroup}
 */
TestGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new TestGroup.RepeatedGroup;
      reader.readGroup(1, value,TestGroup.RepeatedGroup.deserializeBinaryFromReader);
      msg.addRepeatedGroup(value);
      break;
    case 2:
      var value = new TestGroup.RequiredGroup;
      reader.readGroup(2, value,TestGroup.RequiredGroup.deserializeBinaryFromReader);
      msg.setRequiredGroup(value);
      break;
    case 3:
      var value = new TestGroup.OptionalGroup;
      reader.readGroup(3, value,TestGroup.OptionalGroup.deserializeBinaryFromReader);
      msg.setOptionalGroup(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 5:
      var value = new Simple2;
      reader.readMessage(value,Simple2.deserializeBinaryFromReader);
      msg.setRequiredSimple(value);
      break;
    case 6:
      var value = new Simple2;
      reader.readMessage(value,Simple2.deserializeBinaryFromReader);
      msg.setOptionalSimple(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRepeatedGroupList();
  if (f.length > 0) {
    writer.writeRepeatedGroup(
      1,
      f,
      TestGroup.RepeatedGroup.serializeBinaryToWriter
    );
  }
  f = message.getRequiredGroup();
  if (f != null) {
    writer.writeGroup(
      2,
      f,
      TestGroup.RequiredGroup.serializeBinaryToWriter
    );
  }
  f = message.getOptionalGroup();
  if (f != null) {
    writer.writeGroup(
      3,
      f,
      TestGroup.OptionalGroup.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getRequiredSimple();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      Simple2.serializeBinaryToWriter
    );
  }
  f = message.getOptionalSimple();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      Simple2.serializeBinaryToWriter
    );
  }
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
TestGroup.RepeatedGroup.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestGroup.RepeatedGroup.prototype.toObject = function(opt_includeInstance) {
  return TestGroup.RepeatedGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestGroup.RepeatedGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.RepeatedGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
id: (f = jspb.Message.getField(msg, 0)) == null ? undefined : f,
someBoolList: (f = jspb.Message.getRepeatedBooleanField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup}
 */
TestGroup.RepeatedGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestGroup.RepeatedGroup;
  return TestGroup.RepeatedGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestGroup.RepeatedGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup}
 */
TestGroup.RepeatedGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var values = /** @type {!Array<boolean>} */ (reader.isDelimited() ? reader.readBool() : [reader.readBool()]);
      for (var i = 0; i < values.length; i++) {
        msg.addSomeBool(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestGroup.RepeatedGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestGroup.RepeatedGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestGroup.RepeatedGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.RepeatedGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 0));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSomeBoolList();
  if (f.length > 0) {
    writer.writeRepeatedBool(
      2,
      f
    );
  }
};


/**
 * required string id = 1;
 * @return {string}
 */
TestGroup.RepeatedGroup.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 0, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup} returns this
 */
TestGroup.RepeatedGroup.prototype.setId = function(value) {
  return jspb.Message.setField(this, 0, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup} returns this
 */
TestGroup.RepeatedGroup.prototype.clearId = function() {
  return jspb.Message.setField(this, 0, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.RepeatedGroup.prototype.hasId = function() {
  return jspb.Message.getField(this, 0) != null;
};


/**
 * repeated bool some_bool = 2;
 * @return {!Array<boolean>}
 */
TestGroup.RepeatedGroup.prototype.getSomeBoolList = function() {
  return /** @type {!Array<boolean>} */ (jspb.Message.getRepeatedBooleanField(this, 1));
};


/**
 * @param {!Array<boolean>} value
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup} returns this
 */
TestGroup.RepeatedGroup.prototype.setSomeBoolList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {boolean} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup} returns this
 */
TestGroup.RepeatedGroup.prototype.addSomeBool = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup} returns this
 */
TestGroup.RepeatedGroup.prototype.clearSomeBoolList = function() {
  return this.setSomeBoolList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestGroup.RequiredGroup.prototype.toObject = function(opt_includeInstance) {
  return TestGroup.RequiredGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestGroup.RequiredGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.RequiredGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
id: (f = jspb.Message.getField(msg, -1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestGroup.RequiredGroup}
 */
TestGroup.RequiredGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestGroup.RequiredGroup;
  return TestGroup.RequiredGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestGroup.RequiredGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestGroup.RequiredGroup}
 */
TestGroup.RequiredGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestGroup.RequiredGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestGroup.RequiredGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestGroup.RequiredGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.RequiredGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, -1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string id = 1;
 * @return {string}
 */
TestGroup.RequiredGroup.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, -1, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestGroup.RequiredGroup} returns this
 */
TestGroup.RequiredGroup.prototype.setId = function(value) {
  return jspb.Message.setField(this, -1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup.RequiredGroup} returns this
 */
TestGroup.RequiredGroup.prototype.clearId = function() {
  return jspb.Message.setField(this, -1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.RequiredGroup.prototype.hasId = function() {
  return jspb.Message.getField(this, -1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestGroup.OptionalGroup.prototype.toObject = function(opt_includeInstance) {
  return TestGroup.OptionalGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestGroup.OptionalGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.OptionalGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
id: (f = jspb.Message.getField(msg, -2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestGroup.OptionalGroup}
 */
TestGroup.OptionalGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestGroup.OptionalGroup;
  return TestGroup.OptionalGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestGroup.OptionalGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestGroup.OptionalGroup}
 */
TestGroup.OptionalGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestGroup.OptionalGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestGroup.OptionalGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestGroup.OptionalGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup.OptionalGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, -2));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string id = 1;
 * @return {string}
 */
TestGroup.OptionalGroup.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, -2, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestGroup.OptionalGroup} returns this
 */
TestGroup.OptionalGroup.prototype.setId = function(value) {
  return jspb.Message.setField(this, -2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup.OptionalGroup} returns this
 */
TestGroup.OptionalGroup.prototype.clearId = function() {
  return jspb.Message.setField(this, -2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.OptionalGroup.prototype.hasId = function() {
  return jspb.Message.getField(this, -2) != null;
};


/**
 * repeated group RepeatedGroup = 1;
 * @return {!Array<!proto.jspb.test.TestGroup.RepeatedGroup>}
 */
TestGroup.prototype.getRepeatedGroupList = function() {
  return /** @type{!Array<!proto.jspb.test.TestGroup.RepeatedGroup>} */ (
    jspb.Message.getRepeatedWrapperField(this, TestGroup.RepeatedGroup, 1));
};


/**
 * @param {!Array<!proto.jspb.test.TestGroup.RepeatedGroup>} value
 * @return {!proto.jspb.test.TestGroup} returns this
*/
TestGroup.prototype.setRepeatedGroupList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.jspb.test.TestGroup.RepeatedGroup=} opt_value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.TestGroup.RepeatedGroup}
 */
TestGroup.prototype.addRepeatedGroup = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, TestGroup.RepeatedGroup, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearRepeatedGroupList = function() {
  return this.setRepeatedGroupList([]);
};


/**
 * required group RequiredGroup = 2;
 * @return {!proto.jspb.test.TestGroup.RequiredGroup}
 */
TestGroup.prototype.getRequiredGroup = function() {
  return /** @type{!proto.jspb.test.TestGroup.RequiredGroup} */ (
    jspb.Message.getWrapperField(this, TestGroup.RequiredGroup, 2, 1));
};


/**
 * @param {!proto.jspb.test.TestGroup.RequiredGroup} value
 * @return {!proto.jspb.test.TestGroup} returns this
*/
TestGroup.prototype.setRequiredGroup = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearRequiredGroup = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.prototype.hasRequiredGroup = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional group OptionalGroup = 3;
 * @return {?proto.jspb.test.TestGroup.OptionalGroup}
 */
TestGroup.prototype.getOptionalGroup = function() {
  return /** @type{?proto.jspb.test.TestGroup.OptionalGroup} */ (
    jspb.Message.getWrapperField(this, TestGroup.OptionalGroup, 3));
};


/**
 * @param {?proto.jspb.test.TestGroup.OptionalGroup|undefined} value
 * @return {!proto.jspb.test.TestGroup} returns this
*/
TestGroup.prototype.setOptionalGroup = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearOptionalGroup = function() {
  return this.setOptionalGroup(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.prototype.hasOptionalGroup = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string id = 4;
 * @return {string}
 */
TestGroup.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.setId = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearId = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.prototype.hasId = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * required Simple2 required_simple = 5;
 * @return {!proto.jspb.test.Simple2}
 */
TestGroup.prototype.getRequiredSimple = function() {
  return /** @type{!proto.jspb.test.Simple2} */ (
    jspb.Message.getWrapperField(this, Simple2, 5, 1));
};


/**
 * @param {!proto.jspb.test.Simple2} value
 * @return {!proto.jspb.test.TestGroup} returns this
*/
TestGroup.prototype.setRequiredSimple = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearRequiredSimple = function() {
  return jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.prototype.hasRequiredSimple = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Simple2 optional_simple = 6;
 * @return {?proto.jspb.test.Simple2}
 */
TestGroup.prototype.getOptionalSimple = function() {
  return /** @type{?proto.jspb.test.Simple2} */ (
    jspb.Message.getWrapperField(this, Simple2, 6));
};


/**
 * @param {?proto.jspb.test.Simple2|undefined} value
 * @return {!proto.jspb.test.TestGroup} returns this
*/
TestGroup.prototype.setOptionalSimple = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestGroup} returns this
 */
TestGroup.prototype.clearOptionalSimple = function() {
  return this.setOptionalSimple(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup.prototype.hasOptionalSimple = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestGroup1.prototype.toObject = function(opt_includeInstance) {
  return TestGroup1.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestGroup1} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup1.toObject = function(includeInstance, msg) {
  var f, obj = {
group: (f = msg.getGroup()) && TestGroup.RepeatedGroup.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestGroup1}
 */
TestGroup1.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestGroup1;
  return TestGroup1.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestGroup1} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestGroup1}
 */
TestGroup1.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new TestGroup.RepeatedGroup;
      reader.readMessage(value,TestGroup.RepeatedGroup.deserializeBinaryFromReader);
      msg.setGroup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestGroup1.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestGroup1.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestGroup1} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestGroup1.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getGroup();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      TestGroup.RepeatedGroup.serializeBinaryToWriter
    );
  }
};


/**
 * optional TestGroup.RepeatedGroup group = 1;
 * @return {?proto.jspb.test.TestGroup.RepeatedGroup}
 */
TestGroup1.prototype.getGroup = function() {
  return /** @type{?proto.jspb.test.TestGroup.RepeatedGroup} */ (
    jspb.Message.getWrapperField(this, TestGroup.RepeatedGroup, 1));
};


/**
 * @param {?proto.jspb.test.TestGroup.RepeatedGroup|undefined} value
 * @return {!proto.jspb.test.TestGroup1} returns this
*/
TestGroup1.prototype.setGroup = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestGroup1} returns this
 */
TestGroup1.prototype.clearGroup = function() {
  return this.setGroup(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestGroup1.prototype.hasGroup = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestReservedNames.prototype.toObject = function(opt_includeInstance) {
  return TestReservedNames.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestReservedNames} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestReservedNames.toObject = function(includeInstance, msg) {
  var f, obj = {
extension: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  jspb.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
      TestReservedNames.extensions, TestReservedNames.prototype.getExtension,
      includeInstance);
  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestReservedNames}
 */
TestReservedNames.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestReservedNames;
  return TestReservedNames.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestReservedNames} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestReservedNames}
 */
TestReservedNames.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExtension$(value);
      break;
    default:
      jspb.Message.readBinaryExtension(msg, reader,
        TestReservedNames.extensionsBinary,
        TestReservedNames.prototype.getExtension,
        TestReservedNames.prototype.setExtension);
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestReservedNames.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestReservedNames.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestReservedNames} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestReservedNames.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  jspb.Message.serializeBinaryExtensions(message, writer,
    TestReservedNames.extensionsBinary, TestReservedNames.prototype.getExtension);
};


/**
 * optional int32 extension = 1;
 * @return {number}
 */
TestReservedNames.prototype.getExtension$ = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestReservedNames} returns this
 */
TestReservedNames.prototype.setExtension$ = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestReservedNames} returns this
 */
TestReservedNames.prototype.clearExtension$ = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestReservedNames.prototype.hasExtension$ = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestReservedNamesExtension.prototype.toObject = function(opt_includeInstance) {
  return TestReservedNamesExtension.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestReservedNamesExtension} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestReservedNamesExtension.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestReservedNamesExtension}
 */
TestReservedNamesExtension.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestReservedNamesExtension;
  return TestReservedNamesExtension.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestReservedNamesExtension} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestReservedNamesExtension}
 */
TestReservedNamesExtension.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestReservedNamesExtension.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestReservedNamesExtension.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestReservedNamesExtension} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestReservedNamesExtension.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * A tuple of {field number, class constructor} for the extension
 * field named `foo`.
 * @type {!jspb.ExtensionFieldInfo<number>}
 */
TestReservedNamesExtension.foo = new jspb.ExtensionFieldInfo(
    10,
    {foo: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

TestReservedNames.extensionsBinary[10] = new jspb.ExtensionFieldBinaryInfo(
    TestReservedNamesExtension.foo,
    jspb.BinaryReader.prototype.readInt32,
    jspb.BinaryWriter.prototype.writeInt32,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestReservedNames.extensions[10] = TestReservedNamesExtension.foo;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `foo`.
 * @type {!jspb.ExtensionFieldInfo<number>}
 */
TestReservedNamesExtension.foo = new jspb.ExtensionFieldInfo(
    10,
    {foo: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

TestReservedNames.extensionsBinary[10] = new jspb.ExtensionFieldBinaryInfo(
    TestReservedNamesExtension.foo,
    jspb.BinaryReader.prototype.readInt32,
    jspb.BinaryWriter.prototype.writeInt32,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestReservedNames.extensions[10] = TestReservedNamesExtension.foo;


/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
TestMessageWithOneof.repeatedFields_ = [9];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
TestMessageWithOneof.oneofGroups_ = [[3,5],[6,7],[10,11],[12,13]];

/**
 * @enum {number}
 */
TestMessageWithOneof.PartialOneofCase = {
  PARTIAL_ONEOF_NOT_SET: 0,
  PONE: 3,
  PTHREE: 5
};

/**
 * @return {proto.jspb.test.TestMessageWithOneof.PartialOneofCase}
 */
TestMessageWithOneof.prototype.getPartialOneofCase = function() {
  return /** @type {proto.jspb.test.TestMessageWithOneof.PartialOneofCase} */(jspb.Message.computeOneofCase(this, TestMessageWithOneof.oneofGroups_[0]));
};

/**
 * @enum {number}
 */
TestMessageWithOneof.RecursiveOneofCase = {
  RECURSIVE_ONEOF_NOT_SET: 0,
  RONE: 6,
  RTWO: 7
};

/**
 * @return {proto.jspb.test.TestMessageWithOneof.RecursiveOneofCase}
 */
TestMessageWithOneof.prototype.getRecursiveOneofCase = function() {
  return /** @type {proto.jspb.test.TestMessageWithOneof.RecursiveOneofCase} */(jspb.Message.computeOneofCase(this, TestMessageWithOneof.oneofGroups_[1]));
};

/**
 * @enum {number}
 */
TestMessageWithOneof.DefaultOneofACase = {
  DEFAULT_ONEOF_A_NOT_SET: 0,
  AONE: 10,
  ATWO: 11
};

/**
 * @return {proto.jspb.test.TestMessageWithOneof.DefaultOneofACase}
 */
TestMessageWithOneof.prototype.getDefaultOneofACase = function() {
  return /** @type {proto.jspb.test.TestMessageWithOneof.DefaultOneofACase} */(jspb.Message.computeOneofCase(this, TestMessageWithOneof.oneofGroups_[2]));
};

/**
 * @enum {number}
 */
TestMessageWithOneof.DefaultOneofBCase = {
  DEFAULT_ONEOF_B_NOT_SET: 0,
  BONE: 12,
  BTWO: 13
};

/**
 * @return {proto.jspb.test.TestMessageWithOneof.DefaultOneofBCase}
 */
TestMessageWithOneof.prototype.getDefaultOneofBCase = function() {
  return /** @type {proto.jspb.test.TestMessageWithOneof.DefaultOneofBCase} */(jspb.Message.computeOneofCase(this, TestMessageWithOneof.oneofGroups_[3]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestMessageWithOneof.prototype.toObject = function(opt_includeInstance) {
  return TestMessageWithOneof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestMessageWithOneof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestMessageWithOneof.toObject = function(includeInstance, msg) {
  var f, obj = {
pone: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
pthree: (f = jspb.Message.getField(msg, 5)) == null ? undefined : f,
rone: (f = msg.getRone()) && TestMessageWithOneof.toObject(includeInstance, f),
rtwo: (f = jspb.Message.getField(msg, 7)) == null ? undefined : f,
normalField: (f = jspb.Message.getBooleanField(msg, 8)) == null ? undefined : f,
repeatedFieldList: (f = jspb.Message.getRepeatedField(msg, 9)) == null ? undefined : f,
aone: jspb.Message.getFieldWithDefault(msg, 10, 1234),
atwo: (f = jspb.Message.getField(msg, 11)) == null ? undefined : f,
bone: (f = jspb.Message.getField(msg, 12)) == null ? undefined : f,
btwo: jspb.Message.getFieldWithDefault(msg, 13, 1234)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestMessageWithOneof}
 */
TestMessageWithOneof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestMessageWithOneof;
  return TestMessageWithOneof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestMessageWithOneof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestMessageWithOneof}
 */
TestMessageWithOneof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPone(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPthree(value);
      break;
    case 6:
      var value = new TestMessageWithOneof;
      reader.readMessage(value,TestMessageWithOneof.deserializeBinaryFromReader);
      msg.setRone(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setRtwo(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNormalField(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.addRepeatedField(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAone(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAtwo(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBone(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBtwo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestMessageWithOneof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestMessageWithOneof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestMessageWithOneof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestMessageWithOneof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getRone();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      TestMessageWithOneof.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeString(
      7,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getRepeatedFieldList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeInt32(
      10,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeInt32(
      11,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeInt32(
      12,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeInt32(
      13,
      f
    );
  }
};


/**
 * optional string pone = 3;
 * @return {string}
 */
TestMessageWithOneof.prototype.getPone = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setPone = function(value) {
  return jspb.Message.setOneofField(this, 3, TestMessageWithOneof.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearPone = function() {
  return jspb.Message.setOneofField(this, 3, TestMessageWithOneof.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasPone = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string pthree = 5;
 * @return {string}
 */
TestMessageWithOneof.prototype.getPthree = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setPthree = function(value) {
  return jspb.Message.setOneofField(this, 5, TestMessageWithOneof.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearPthree = function() {
  return jspb.Message.setOneofField(this, 5, TestMessageWithOneof.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasPthree = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional TestMessageWithOneof rone = 6;
 * @return {?proto.jspb.test.TestMessageWithOneof}
 */
TestMessageWithOneof.prototype.getRone = function() {
  return /** @type{?proto.jspb.test.TestMessageWithOneof} */ (
    jspb.Message.getWrapperField(this, TestMessageWithOneof, 6));
};


/**
 * @param {?proto.jspb.test.TestMessageWithOneof|undefined} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
*/
TestMessageWithOneof.prototype.setRone = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, TestMessageWithOneof.oneofGroups_[1], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearRone = function() {
  return this.setRone(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasRone = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional string rtwo = 7;
 * @return {string}
 */
TestMessageWithOneof.prototype.getRtwo = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setRtwo = function(value) {
  return jspb.Message.setOneofField(this, 7, TestMessageWithOneof.oneofGroups_[1], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearRtwo = function() {
  return jspb.Message.setOneofField(this, 7, TestMessageWithOneof.oneofGroups_[1], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasRtwo = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bool normal_field = 8;
 * @return {boolean}
 */
TestMessageWithOneof.prototype.getNormalField = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 8, false));
};


/**
 * @param {boolean} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setNormalField = function(value) {
  return jspb.Message.setField(this, 8, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearNormalField = function() {
  return jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasNormalField = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * repeated string repeated_field = 9;
 * @return {!Array<string>}
 */
TestMessageWithOneof.prototype.getRepeatedFieldList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 9));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setRepeatedFieldList = function(value) {
  return jspb.Message.setField(this, 9, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.addRepeatedField = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 9, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearRepeatedFieldList = function() {
  return this.setRepeatedFieldList([]);
};


/**
 * optional int32 aone = 10;
 * @return {number}
 */
TestMessageWithOneof.prototype.getAone = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 1234));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setAone = function(value) {
  return jspb.Message.setOneofField(this, 10, TestMessageWithOneof.oneofGroups_[2], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearAone = function() {
  return jspb.Message.setOneofField(this, 10, TestMessageWithOneof.oneofGroups_[2], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasAone = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional int32 atwo = 11;
 * @return {number}
 */
TestMessageWithOneof.prototype.getAtwo = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setAtwo = function(value) {
  return jspb.Message.setOneofField(this, 11, TestMessageWithOneof.oneofGroups_[2], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearAtwo = function() {
  return jspb.Message.setOneofField(this, 11, TestMessageWithOneof.oneofGroups_[2], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasAtwo = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional int32 bone = 12;
 * @return {number}
 */
TestMessageWithOneof.prototype.getBone = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setBone = function(value) {
  return jspb.Message.setOneofField(this, 12, TestMessageWithOneof.oneofGroups_[3], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearBone = function() {
  return jspb.Message.setOneofField(this, 12, TestMessageWithOneof.oneofGroups_[3], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasBone = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional int32 btwo = 13;
 * @return {number}
 */
TestMessageWithOneof.prototype.getBtwo = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 1234));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.setBtwo = function(value) {
  return jspb.Message.setOneofField(this, 13, TestMessageWithOneof.oneofGroups_[3], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestMessageWithOneof} returns this
 */
TestMessageWithOneof.prototype.clearBtwo = function() {
  return jspb.Message.setOneofField(this, 13, TestMessageWithOneof.oneofGroups_[3], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMessageWithOneof.prototype.hasBtwo = function() {
  return jspb.Message.getField(this, 13) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestEndsWithBytes.prototype.toObject = function(opt_includeInstance) {
  return TestEndsWithBytes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestEndsWithBytes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestEndsWithBytes.toObject = function(includeInstance, msg) {
  var f, obj = {
value: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestEndsWithBytes}
 */
TestEndsWithBytes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestEndsWithBytes;
  return TestEndsWithBytes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestEndsWithBytes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestEndsWithBytes}
 */
TestEndsWithBytes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestEndsWithBytes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestEndsWithBytes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestEndsWithBytes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestEndsWithBytes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional int32 value = 1;
 * @return {number}
 */
TestEndsWithBytes.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestEndsWithBytes} returns this
 */
TestEndsWithBytes.prototype.setValue = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestEndsWithBytes} returns this
 */
TestEndsWithBytes.prototype.clearValue = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestEndsWithBytes.prototype.hasValue = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes data = 2;
 * @return {!(string|Uint8Array)}
 */
TestEndsWithBytes.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes data = 2;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
TestEndsWithBytes.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
TestEndsWithBytes.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.jspb.test.TestEndsWithBytes} returns this
 */
TestEndsWithBytes.prototype.setData = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestEndsWithBytes} returns this
 */
TestEndsWithBytes.prototype.clearData = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestEndsWithBytes.prototype.hasData = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestLastFieldBeforePivot.prototype.toObject = function(opt_includeInstance) {
  return TestLastFieldBeforePivot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestLastFieldBeforePivot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestLastFieldBeforePivot.toObject = function(includeInstance, msg) {
  var f, obj = {
lastFieldBeforePivot: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  jspb.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
      TestLastFieldBeforePivot.extensions, TestLastFieldBeforePivot.prototype.getExtension,
      includeInstance);
  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestLastFieldBeforePivot}
 */
TestLastFieldBeforePivot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestLastFieldBeforePivot;
  return TestLastFieldBeforePivot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestLastFieldBeforePivot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestLastFieldBeforePivot}
 */
TestLastFieldBeforePivot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setLastFieldBeforePivot(value);
      break;
    default:
      jspb.Message.readBinaryExtension(msg, reader,
        TestLastFieldBeforePivot.extensionsBinary,
        TestLastFieldBeforePivot.prototype.getExtension,
        TestLastFieldBeforePivot.prototype.setExtension);
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestLastFieldBeforePivot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestLastFieldBeforePivot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestLastFieldBeforePivot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestLastFieldBeforePivot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  jspb.Message.serializeBinaryExtensions(message, writer,
    TestLastFieldBeforePivot.extensionsBinary, TestLastFieldBeforePivot.prototype.getExtension);
};


/**
 * optional int32 last_field_before_pivot = 1;
 * @return {number}
 */
TestLastFieldBeforePivot.prototype.getLastFieldBeforePivot = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.TestLastFieldBeforePivot} returns this
 */
TestLastFieldBeforePivot.prototype.setLastFieldBeforePivot = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.TestLastFieldBeforePivot} returns this
 */
TestLastFieldBeforePivot.prototype.clearLastFieldBeforePivot = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestLastFieldBeforePivot.prototype.hasLastFieldBeforePivot = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Int64Types.prototype.toObject = function(opt_includeInstance) {
  return Int64Types.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Int64Types} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Int64Types.toObject = function(includeInstance, msg) {
  var f, obj = {
int64Normal: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
int64String: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
int64Number: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Int64Types}
 */
Int64Types.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Int64Types;
  return Int64Types.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Int64Types} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Int64Types}
 */
Int64Types.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setInt64Normal(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readSint64String());
      msg.setInt64String(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setInt64Number(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Int64Types.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Int64Types.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Int64Types} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Int64Types.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeSint64String(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional int64 int64_normal = 1;
 * @return {number}
 */
Int64Types.prototype.getInt64Normal = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.setInt64Normal = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.clearInt64Normal = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Int64Types.prototype.hasInt64Normal = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional sint64 int64_string = 2;
 * @return {string}
 */
Int64Types.prototype.getInt64String = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.setInt64String = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.clearInt64String = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Int64Types.prototype.hasInt64String = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 int64_number = 3;
 * @return {number}
 */
Int64Types.prototype.getInt64Number = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.setInt64Number = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Int64Types} returns this
 */
Int64Types.prototype.clearInt64Number = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Int64Types.prototype.hasInt64Number = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
TestMapFieldsNoBinary.prototype.toObject = function(opt_includeInstance) {
  return TestMapFieldsNoBinary.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.TestMapFieldsNoBinary} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestMapFieldsNoBinary.toObject = function(includeInstance, msg) {
  var f, obj = {
mapStringStringMap: (f = msg.getMapStringStringMap()) ? f.toObject(includeInstance, undefined) : [],
mapStringInt32Map: (f = msg.getMapStringInt32Map()) ? f.toObject(includeInstance, undefined) : [],
mapStringInt64Map: (f = msg.getMapStringInt64Map()) ? f.toObject(includeInstance, undefined) : [],
mapStringBoolMap: (f = msg.getMapStringBoolMap()) ? f.toObject(includeInstance, undefined) : [],
mapStringDoubleMap: (f = msg.getMapStringDoubleMap()) ? f.toObject(includeInstance, undefined) : [],
mapStringEnumMap: (f = msg.getMapStringEnumMap()) ? f.toObject(includeInstance, undefined) : [],
mapStringMsgMap: (f = msg.getMapStringMsgMap()) ? f.toObject(includeInstance, MapValueMessageNoBinary.toObject) : [],
mapInt32StringMap: (f = msg.getMapInt32StringMap()) ? f.toObject(includeInstance, undefined) : [],
mapInt64StringMap: (f = msg.getMapInt64StringMap()) ? f.toObject(includeInstance, undefined) : [],
mapBoolStringMap: (f = msg.getMapBoolStringMap()) ? f.toObject(includeInstance, undefined) : [],
testMapFields: (f = msg.getTestMapFields()) && TestMapFieldsNoBinary.toObject(includeInstance, f),
mapStringTestmapfieldsMap: (f = msg.getMapStringTestmapfieldsMap()) ? f.toObject(includeInstance, TestMapFieldsNoBinary.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary}
 */
TestMapFieldsNoBinary.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new TestMapFieldsNoBinary;
  return TestMapFieldsNoBinary.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.TestMapFieldsNoBinary} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary}
 */
TestMapFieldsNoBinary.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getMapStringStringMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readString, null, "", "");
         });
      break;
    case 2:
      var value = msg.getMapStringInt32Map();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt32, null, "", 0);
         });
      break;
    case 3:
      var value = msg.getMapStringInt64Map();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
         });
      break;
    case 4:
      var value = msg.getMapStringBoolMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readBool, null, "", false);
         });
      break;
    case 5:
      var value = msg.getMapStringDoubleMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readDouble, null, "", 0.0);
         });
      break;
    case 6:
      var value = msg.getMapStringEnumMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readEnum, null, "", 0);
         });
      break;
    case 7:
      var value = msg.getMapStringMsgMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, MapValueMessageNoBinary.deserializeBinaryFromReader, "", new MapValueMessageNoBinary());
         });
      break;
    case 8:
      var value = msg.getMapInt32StringMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readInt32, jspb.BinaryReader.prototype.readString, null, 0, "");
         });
      break;
    case 9:
      var value = msg.getMapInt64StringMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readInt64, jspb.BinaryReader.prototype.readString, null, 0, "");
         });
      break;
    case 10:
      var value = msg.getMapBoolStringMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readBool, jspb.BinaryReader.prototype.readString, null, false, "");
         });
      break;
    case 11:
      var value = new TestMapFieldsNoBinary;
      reader.readMessage(value,TestMapFieldsNoBinary.deserializeBinaryFromReader);
      msg.setTestMapFields(value);
      break;
    case 12:
      var value = msg.getMapStringTestmapfieldsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, TestMapFieldsNoBinary.deserializeBinaryFromReader, "", new TestMapFieldsNoBinary());
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
TestMapFieldsNoBinary.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  TestMapFieldsNoBinary.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.TestMapFieldsNoBinary} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
TestMapFieldsNoBinary.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMapStringStringMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getMapStringInt32Map(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt32);
  }
  f = message.getMapStringInt64Map(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(3, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
  }
  f = message.getMapStringBoolMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeBool);
  }
  f = message.getMapStringDoubleMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeDouble);
  }
  f = message.getMapStringEnumMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(6, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeEnum);
  }
  f = message.getMapStringMsgMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(7, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, MapValueMessageNoBinary.serializeBinaryToWriter);
  }
  f = message.getMapInt32StringMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(8, writer, jspb.BinaryWriter.prototype.writeInt32, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getMapInt64StringMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(9, writer, jspb.BinaryWriter.prototype.writeInt64, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getMapBoolStringMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(10, writer, jspb.BinaryWriter.prototype.writeBool, jspb.BinaryWriter.prototype.writeString);
  }
  f = message.getTestMapFields();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      TestMapFieldsNoBinary.serializeBinaryToWriter
    );
  }
  f = message.getMapStringTestmapfieldsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(12, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, TestMapFieldsNoBinary.serializeBinaryToWriter);
  }
};


/**
 * map<string, string> map_string_string = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,string>}
 */
TestMapFieldsNoBinary.prototype.getMapStringStringMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,string>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringStringMap = function() {
  this.getMapStringStringMap().clear();
  return this;
};


/**
 * map<string, int32> map_string_int32 = 2;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
TestMapFieldsNoBinary.prototype.getMapStringInt32Map = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 2, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringInt32Map = function() {
  this.getMapStringInt32Map().clear();
  return this;
};


/**
 * map<string, int64> map_string_int64 = 3;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
TestMapFieldsNoBinary.prototype.getMapStringInt64Map = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 3, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringInt64Map = function() {
  this.getMapStringInt64Map().clear();
  return this;
};


/**
 * map<string, bool> map_string_bool = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,boolean>}
 */
TestMapFieldsNoBinary.prototype.getMapStringBoolMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,boolean>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringBoolMap = function() {
  this.getMapStringBoolMap().clear();
  return this;
};


/**
 * map<string, double> map_string_double = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
TestMapFieldsNoBinary.prototype.getMapStringDoubleMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 5, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringDoubleMap = function() {
  this.getMapStringDoubleMap().clear();
  return this;
};


/**
 * map<string, MapValueEnumNoBinary> map_string_enum = 6;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.jspb.test.MapValueEnumNoBinary>}
 */
TestMapFieldsNoBinary.prototype.getMapStringEnumMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.jspb.test.MapValueEnumNoBinary>} */ (
      jspb.Message.getMapField(this, 6, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringEnumMap = function() {
  this.getMapStringEnumMap().clear();
  return this;
};


/**
 * map<string, MapValueMessageNoBinary> map_string_msg = 7;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.jspb.test.MapValueMessageNoBinary>}
 */
TestMapFieldsNoBinary.prototype.getMapStringMsgMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.jspb.test.MapValueMessageNoBinary>} */ (
      jspb.Message.getMapField(this, 7, opt_noLazyCreate,
      MapValueMessageNoBinary));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringMsgMap = function() {
  this.getMapStringMsgMap().clear();
  return this;
};


/**
 * map<int32, string> map_int32_string = 8;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,string>}
 */
TestMapFieldsNoBinary.prototype.getMapInt32StringMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,string>} */ (
      jspb.Message.getMapField(this, 8, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapInt32StringMap = function() {
  this.getMapInt32StringMap().clear();
  return this;
};


/**
 * map<int64, string> map_int64_string = 9;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,string>}
 */
TestMapFieldsNoBinary.prototype.getMapInt64StringMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,string>} */ (
      jspb.Message.getMapField(this, 9, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapInt64StringMap = function() {
  this.getMapInt64StringMap().clear();
  return this;
};


/**
 * map<bool, string> map_bool_string = 10;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<boolean,string>}
 */
TestMapFieldsNoBinary.prototype.getMapBoolStringMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<boolean,string>} */ (
      jspb.Message.getMapField(this, 10, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapBoolStringMap = function() {
  this.getMapBoolStringMap().clear();
  return this;
};


/**
 * optional TestMapFieldsNoBinary test_map_fields = 11;
 * @return {?proto.jspb.test.TestMapFieldsNoBinary}
 */
TestMapFieldsNoBinary.prototype.getTestMapFields = function() {
  return /** @type{?proto.jspb.test.TestMapFieldsNoBinary} */ (
    jspb.Message.getWrapperField(this, TestMapFieldsNoBinary, 11));
};


/**
 * @param {?proto.jspb.test.TestMapFieldsNoBinary|undefined} value
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
*/
TestMapFieldsNoBinary.prototype.setTestMapFields = function(value) {
  return jspb.Message.setWrapperField(this, 11, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearTestMapFields = function() {
  return this.setTestMapFields(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
TestMapFieldsNoBinary.prototype.hasTestMapFields = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * map<string, TestMapFieldsNoBinary> map_string_testmapfields = 12;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.jspb.test.TestMapFieldsNoBinary>}
 */
TestMapFieldsNoBinary.prototype.getMapStringTestmapfieldsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.jspb.test.TestMapFieldsNoBinary>} */ (
      jspb.Message.getMapField(this, 12, opt_noLazyCreate,
      TestMapFieldsNoBinary));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.jspb.test.TestMapFieldsNoBinary} returns this
 */
TestMapFieldsNoBinary.prototype.clearMapStringTestmapfieldsMap = function() {
  this.getMapStringTestmapfieldsMap().clear();
  return this;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
MapValueMessageNoBinary.prototype.toObject = function(opt_includeInstance) {
  return MapValueMessageNoBinary.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.MapValueMessageNoBinary} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
MapValueMessageNoBinary.toObject = function(includeInstance, msg) {
  var f, obj = {
foo: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.MapValueMessageNoBinary}
 */
MapValueMessageNoBinary.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new MapValueMessageNoBinary;
  return MapValueMessageNoBinary.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.MapValueMessageNoBinary} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.MapValueMessageNoBinary}
 */
MapValueMessageNoBinary.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFoo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
MapValueMessageNoBinary.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  MapValueMessageNoBinary.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.MapValueMessageNoBinary} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
MapValueMessageNoBinary.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 foo = 1;
 * @return {number}
 */
MapValueMessageNoBinary.prototype.getFoo = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.MapValueMessageNoBinary} returns this
 */
MapValueMessageNoBinary.prototype.setFoo = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.MapValueMessageNoBinary} returns this
 */
MapValueMessageNoBinary.prototype.clearFoo = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
MapValueMessageNoBinary.prototype.hasFoo = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Deeply.prototype.toObject = function(opt_includeInstance) {
  return Deeply.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Deeply} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Deeply}
 */
Deeply.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Deeply;
  return Deeply.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Deeply} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Deeply}
 */
Deeply.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Deeply.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Deeply.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Deeply} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Deeply.Nested.prototype.toObject = function(opt_includeInstance) {
  return Deeply.Nested.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Deeply.Nested} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.Nested.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Deeply.Nested}
 */
Deeply.Nested.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Deeply.Nested;
  return Deeply.Nested.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Deeply.Nested} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Deeply.Nested}
 */
Deeply.Nested.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Deeply.Nested.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Deeply.Nested.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Deeply.Nested} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.Nested.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
Deeply.Nested.Message.prototype.toObject = function(opt_includeInstance) {
  return Deeply.Nested.Message.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.jspb.test.Deeply.Nested.Message} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.Nested.Message.toObject = function(includeInstance, msg) {
  var f, obj = {
count: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.jspb.test.Deeply.Nested.Message}
 */
Deeply.Nested.Message.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new Deeply.Nested.Message;
  return Deeply.Nested.Message.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.jspb.test.Deeply.Nested.Message} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.jspb.test.Deeply.Nested.Message}
 */
Deeply.Nested.Message.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
Deeply.Nested.Message.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  Deeply.Nested.Message.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.jspb.test.Deeply.Nested.Message} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
Deeply.Nested.Message.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 count = 1;
 * @return {number}
 */
Deeply.Nested.Message.prototype.getCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.jspb.test.Deeply.Nested.Message} returns this
 */
Deeply.Nested.Message.prototype.setCount = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.jspb.test.Deeply.Nested.Message} returns this
 */
Deeply.Nested.Message.prototype.clearCount = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
Deeply.Nested.Message.prototype.hasCount = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * @enum {number}
 */
export const OuterEnum = {
  FOO: 1,
  BAR: 2
};

/**
 * @enum {number}
 */
export const MapValueEnumNoBinary = {
  MAP_VALUE_FOO_NOBINARY: 0,
  MAP_VALUE_BAR_NOBINARY: 1,
  MAP_VALUE_BAZ_NOBINARY: 2
};

/**
 * @enum {number}
 */
export const TestAllowAliasEnum = {
  TEST_ALLOW_ALIAS_DEFAULT: 0,
  VALUE1: 1
};


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `simple1`.
 * @type {!jspb.ExtensionFieldInfo<!proto.jspb.test.Simple1>}
 */
export const simple1 = new jspb.ExtensionFieldInfo(
    105,
    {simple1: 0},
    Simple1,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         Simple1.toObject),
    0);

HasExtensions.extensionsBinary[105] = new jspb.ExtensionFieldBinaryInfo(
    simple1,
    jspb.BinaryReader.prototype.readMessage,
    jspb.BinaryWriter.prototype.writeMessage,
    Simple1.serializeBinaryToWriter,
    Simple1.deserializeBinaryFromReader,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
HasExtensions.extensions[105] = simple1;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `extendTestLastFieldBeforePivotField`.
 * @type {!jspb.ExtensionFieldInfo<number>}
 */
export const extendTestLastFieldBeforePivotField = new jspb.ExtensionFieldInfo(
    101,
    {extendTestLastFieldBeforePivotField: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

TestLastFieldBeforePivot.extensionsBinary[101] = new jspb.ExtensionFieldBinaryInfo(
    extendTestLastFieldBeforePivotField,
    jspb.BinaryReader.prototype.readInt32,
    jspb.BinaryWriter.prototype.writeInt32,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
TestLastFieldBeforePivot.extensions[101] = extendTestLastFieldBeforePivotField;

export const ComplexNested = Complex.Nested;
export const DeeplyNested = Deeply.Nested;
export const DeeplyNestedMessage = Deeply.Nested.Message;
export const DefaultValuesEnum = DefaultValues.Enum;
export const OptionalFieldsNested = OptionalFields.Nested;
export const OuterMessageComplex = OuterMessage.Complex;
export const TestGroupOptionalGroup = TestGroup.OptionalGroup;
export const TestGroupRepeatedGroup = TestGroup.RepeatedGroup;
export const TestGroupRequiredGroup = TestGroup.RequiredGroup;
export const TestMessageWithOneofDefaultOneofACase = TestMessageWithOneof.DefaultOneofACase;
export const TestMessageWithOneofDefaultOneofBCase = TestMessageWithOneof.DefaultOneofBCase;
export const TestMessageWithOneofPartialOneofCase = TestMessageWithOneof.PartialOneofCase;
export const TestMessageWithOneofRecursiveOneofCase = TestMessageWithOneof.RecursiveOneofCase;
